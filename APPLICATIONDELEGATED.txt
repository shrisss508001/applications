aapdelegate
//
//  AppDelegate.swift
//  PersistData-GU
//
//  Created by Jaimin Raval on 23/09/24.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }
    
    
    //  CoreData:
    


}


sceneDelegate
//
//  SceneDelegate.swift
//  PersistData-GU
//
//  Created by Jaimin Raval on 23/09/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }


}

viewController
//
//  ViewController.swift
//  PersistData-GU
//
//  Created by Jaimin Raval on 23/09/24.
//

import UIKit

class ViewController: UIViewController {

    @IBOutlet weak var nameLbl: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setUsrDefaults()
    }
    
    
    func setUsrDefaults() {
        savetoUsrDefault(key: "User", value: "John Appleseed")
        let str = readFromUsrDefault(key: "User")
        nameLbl.text = String(str)
        print(str)
        navigationItem.title = str
    }

    
    //  persist data using UserDefaults:
    func savetoUsrDefault(key: String, value: Any) {
        let defaults = UserDefaults.standard
        defaults.set(value, forKey: key)
        
    }
    
    
    //  retrive persist data using UserDefaults:
    func readFromUsrDefault(key: String) -> String {
        
        let defaults = UserDefaults.standard
        guard let retrivedData = defaults.string(forKey: key) else { return "" }
        return retrivedData
        
    }
    
    

}












TableTea

Apimanager.swift
//
//  ApiManager.swift
//  table-tea
//
//  Created by Jaimin Raval on 12/09/24.
//

import Foundation
import Alamofire

class ApiManager {
    
    let urlstr = "https://official-joke-api.appspot.com/jokes/random/25"
    
    
    func fetchJokesAF(completionHandler: @escaping(Result<[JokeModel], Error>) -> Void) {
        
        AF.request(urlstr).responseDecodable(of: [JokeModel].self) { response in
            
            switch response.result {
            
            case .success(let data):
                completionHandler(.success(data))
                
            case .failure(let error):
                completionHandler(.failure(error))
            }
    
        }
    }
    
    
    
    
    
    
    
    
    
    
    
//    MARK: - native api call function
//    func fetchJokes(completion: @escaping(Result<[JokeModel],Error>)-> Void) {
//    
//            let urlstr = "https://official-joke-api.appspot.com/jokes/random/25"
//    
//            if let url = URL(string: urlstr) {
//    
//                let session = URLSession.shared
//    
//                let dataTask = session.dataTask(with: url) { data, response, error in
//    
//                    guard let jokeData = data else { return }
//    
//                    do {
//                        let jsonData = try JSONDecoder().decode([JokeModel].self, from: jokeData)
//                        completion(.success(jsonData))
//                        debugPrint(jsonData)
//                    } catch(let err) {
//                        completion(.failure(err))
//                        debugPrint("error in decoding")
//                    }
//    
//                }
//                dataTask.resume()
//    
//            }
//    
//    
//        }
}


//  Current API: https://official-joke-api.appspot.com/jokes/random/25
//  More similar APIs: https://github.com/15Dkatz/official_joke_api


jokemodel
//
//  JokeModel.swift
//  table-tea
//
//  Created by Jaimin Raval on 12/09/24.
//

import Foundation

struct JokeModel: Codable {
    
    let id: Int
    let type: String
    let setup: String
    let punchline: String
    
}

collectionVC
//
//  CollectionVC.swift
//  table-tea
//
//  Created by Jaimin Raval on 17/09/24.
//

import UIKit

class CollectionVC: UIViewController, UICollectionViewDelegate, UICollectionViewDataSource, UICollectionViewDelegateFlowLayout {
    
    @IBOutlet weak var jokeCollection: UICollectionView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupCollectionView()
    }
    

    func setupCollectionView() {
        jokeCollection.delegate = self
        jokeCollection.dataSource = self
        let collectionNib = UINib(nibName: "CollectionCell", bundle: nil)
        jokeCollection.register(collectionNib, forCellWithReuseIdentifier: "CollectionCell")
    }
    
    func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -> Int {
        return 20
    }
    
    func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -> UICollectionViewCell {
        let cell = collectionView.dequeueReusableCell(withReuseIdentifier: "CollectionCell", for: indexPath) as! CollectionCell
        cell.jokeLabel.text = "hahahhahaa"
        return cell
    }
    
    func collectionView(_ collectionView: UICollectionView, layout collectionViewLayout: UICollectionViewLayout, sizeForItemAt indexPath: IndexPath) -> CGSize {
        return CGSize(width: 400, height: 400)
    }

}
DetailVC
//
//  SecondVC.swift
//  table-tea
//
//  Created by Jaimin Raval on 17/09/24.
//

import UIKit

class DetailVC: UIViewController {

    @IBOutlet weak var idLabel: UILabel!
    @IBOutlet weak var typeLabel: UILabel!
    
    @IBOutlet weak var setupLabel: UILabel!
    @IBOutlet weak var punchlineLabel: UILabel!
    
    var currentJoke: JokeModel!
    
    
    override func viewWillAppear(_ animated: Bool) {
        print("-/-/-/-/--/-/-/-/-/-/-/viewWillAppear Loaded")
    }
    
    
//    override func viewDidAppear(_ animated: Bool) {
//        print("-/-/-/-/--/-/-/-/-/-/-/viewDidAppear Loaded")
//    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setJokeData()
//        print("-/-/-/-/--/-/-/-/-/-/-/viewDidLoad Loaded")
    }
    
//    override func viewWillDisappear(_ animated: Bool) {
//        print("-/-/-/-/--/-/-/-/-/-/-/viewWillDisappear Loaded")
//    }
    
//    override func viewDidDisappear(_ animated: Bool) {
//        print("-/-/-/-/--/-/-/-/-/-/-/viewDidDisappear Loaded")
//    }

    func setJokeData() {
        idLabel.text = String(currentJoke.id)
        typeLabel.text = currentJoke.type
        setupLabel.text = currentJoke.setup
        punchlineLabel.text = currentJoke.punchline
        
    }
    
}


TableVC.swift
//
//  TableVC.swift
//  table-tea
//
//  Created by Jaimin Raval on 10/09/24.
//

import UIKit

class TableVC: UIViewController {

    @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!
    
    @IBOutlet weak var JokesTable: UITableView!
    
    var jokes: [JokeModel] = []
    
    private var selectedJoke : JokeModel!
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)

        callJokeApi()
    }

    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setupTable()
    }

    
    func callJokeApi() {
        
        loadingIndicator.startAnimating()
        
        ApiManager().fetchJokesAF { result in
            
            switch result {
                
            case .success(let data):
                
                self.jokes.append(contentsOf: data)
                self.JokesTable.reloadData()
                
                self.loadingIndicator.stopAnimating()
                self.loadingIndicator.isHidden = true
                
            case .failure(let failure):
                
                self.loadingIndicator.stopAnimating()
                self.loadingIndicator.isHidden = true

                debugPrint("something went wrong in calling API: \(failure)")
            }
        }
    }
    
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        
        if segue.identifier == K.JokeDetailSegue {
            
            if let detailVC = segue.destination as? DetailVC {
                
                detailVC.currentJoke = selectedJoke
            }
        }
    }
    
    
//    func saveToUsrDefault(usrName :String) {
//        
//        UserDefaults.standard.set(usrName, forKey: "Usr")
//        
//    }
//    
//    func printUsrDefault() {
//        
//        UserDefaults.standard.value(forKey: "Usr")
//        
//    }
    
    
    
//    func startLoadingIndicator() {
//        
//        DispatchQueue.main.async {
////            self.loadingIndicator.bringSubviewToFront(self.view)
//            self.loadingIndicator.isHidden = false
//            self.loadingIndicator.startAnimating()
//        }
//    }
//    func stopLoadingIndicator() {
//    
//        DispatchQueue.main.async {
////            self.loadingIndicator.bringSubviewToFront(self.view)
//            self.loadingIndicator.isHidden = true
//            self.loadingIndicator.stopAnimating()
//        }
//    }
//    

   
}




extension TableVC: UITableViewDelegate, UITableViewDataSource {

    
    func setupTable() {
        JokesTable.delegate = self
        JokesTable.dataSource = self
        JokesTable.register(UINib(nibName: "JokeCell", bundle: nil), forCellReuseIdentifier: "JokeCell")
    }
    
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return jokes.count
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        selectedJoke = jokes[indexPath.row]
//        tableView.deselectRow(at: indexPath, animated: true)
        
        performSegue(withIdentifier: K.JokeDetailSegue, sender: self)
        
    }
    
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "JokeCell", for: indexPath) as! JokeCell
        cell.nameLabel.text = jokes[indexPath.row].setup
        cell.subtitleLabel.text = jokes[indexPath.row].punchline
        return cell
    }
    
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 200
    }
    
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        
        let delete = UIContextualAction(style: .destructive, title: "Delete") { action, source, completion in
            self.jokes.remove(at: indexPath.row)
            self.JokesTable.deleteRows(at: [indexPath], with: .automatic)
        }
        
        let swipeConfig = UISwipeActionsConfiguration(actions: [delete])
        swipeConfig.performsFirstActionWithFullSwipe = false
        
        return swipeConfig
    }
    
    
    //    func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCell.EditingStyle, forRowAt indexPath: IndexPath) {
    //        if editingStyle == .delete {
    //            jokes.remove(at: indexPath.row)
    //            tableView.deleteRows(at: [indexPath], with: .fade)
    //        }
    //    }
    
    
//    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
//    }
    
}
Constants
//
//  ConstantStrings.swift
//  table-tea
//
//  Created by Jaimin Raval on 01/10/24.
//

import Foundation


final class K {
    static let JokeCellIdentifier = "JokeCell"
    static let CollectionCellIdentifier = "CollectionCell"
    static let JokeDetailSegue = "GoToDetailVC"
    static let DetailSegue = ""
}











EpicEpishod
ContentView.swift
/
//  ContentView.swift
//  Epic-Episodes
//
//  Created by Jaimin Raval on 29/09/24.
//

import SwiftUI

struct ContentView: View {
    
    @State private var episodes: [Episode] = MockData.episodes
    
    var body: some View {
        NavigationStack {
            List {
                ForEach($episodes) { episode in
                    HStack(alignment: .top, spacing: 12) {
                        RoundedRectangle(cornerRadius: 12)
                            .frame(width: 80, height: 80)
                            .foregroundStyle(episode.color.wrappedValue)
                        
                        VStack(alignment: .leading){
                            Text("Episode Title")
                                .font(.subheadline)
                            
                            Text("Here's some brief details and short description of this perticular episode")
                                .font(.subheadline)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
                .onMove{ indexSet, destination in
                    episodes.move(fromOffsets: indexSet, toOffset: destination)
                    var cntr = 0
                    for episode in episodes{
                        episode.listOrder = cntr
                        cntr += 1
                        print("\(episode.title), list order: \(episode.listOrder)")
                    }
                    print("/-/-/-/-/-/-/")
                }
                .navigationTitle("Episodes")
                
            }
        }
    }
}

#Preview {
    ContentView()
}

epicEpishodapp.swift
//
//  Epic_EpisodesApp.swift
//  Epic-Episodes
//
//  Created by Jaimin Raval on 29/09/24.
//

import SwiftUI

@main
struct Epic_EpisodesApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
//            EpisodeView()
        }
    }
}


Epishodview.swift
//
//  EpisodeView.swift
//  Epic-Episodes
//
//  Created by Jaimin Raval on 06/11/24.
//

import SwiftUI

struct EpisodeView: View {
    @State private var episodes: [Episode] = MockData.episodes
    var body: some View {
        NavigationStack {
            List($episodes, editActions: .move){ episode in
//            List(episodes) { episode in
                HStack(alignment: .top, spacing: 12) {
                    RoundedRectangle(cornerRadius: 12)
                        .frame(width: 80, height: 80)
                        .foregroundStyle(episode.color.wrappedValue)
                    
                    VStack(alignment: .leading){
                        Text("Episode Title")
                            .font(.subheadline)
                        
                        Text("Here's some brief details and short description of this perticular episode")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }

                }
            }
            .navigationTitle("Episodes")
            .onChange(of: episodes) { oldValue, newValue in
                var cntr = 0
                for episode in newValue{
                    episode.listOrder = cntr
                    cntr += 1
                    print("\(episode.title), list order: \(episode.listOrder)")
                }
                print("/-/-/-/-/-/-/")
            }
        }
    }
}

class  Episode : Identifiable, Equatable {

    
    let id = UUID()
    var title: String
    var color: Color
    var listOrder: Int
    
    init(title: String, color: Color, listOrder: Int) {
        self.title = title
        self.color = color
        self.listOrder = listOrder
    }
    
    static func == (lhs: Episode, rhs: Episode) -> Bool {
        lhs.id == rhs.id
    }
}


struct MockData {
    static var episodes: [Episode] {
        [Episode(title: "pink", color: .pink, listOrder: 0),
         Episode(title: "blue", color: .blue, listOrder: 0),
         Episode(title: "teal", color: .teal, listOrder: 0),
         Episode(title: "green", color: .green, listOrder: 0),
         Episode(title: "indigo", color: .indigo, listOrder: 0),
         Episode(title: "purple", color: .purple, listOrder: 0),
         Episode(title: "yellow", color: .yellow, listOrder: 0),
         Episode(title: "red", color: .red, listOrder: 0),
         Episode(title: "orange", color: .orange, listOrder: 0),
         Episode(title: "cyan", color: .cyan, listOrder: 0),
         Episode(title: "gray", color: .gray, listOrder: 0),
         Episode(title: "mint", color: .mint, listOrder: 0),
         Episode(title: "primary", color: .primary, listOrder: 0),
         Episode(title: "secondary", color: .secondary, listOrder: 0),
         Episode(title: "brown", color: .brown, listOrder: 0),
         Episode(title: "black", color: .black, listOrder: 0),
        ]
    }
}



#Preview {
    EpisodeView()
}





CD SegmentGU
bookcell


//
//  TableViewCell.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit

class BookCell: UITableViewCell {

    @IBOutlet weak var bName: UILabel!
    
    @IBOutlet weak var bAuthor: UILabel!
    
    @IBOutlet weak var bISBN: UILabel!
    
    @IBOutlet weak var bID: UILabel!
    
    @IBOutlet weak var bUUID: UILabel!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)

        // Configure the view for the selected state
    }
    
}

formVC.swift
//
//  FormVC.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit
import CoreData

class FormVC: UIViewController {

    @IBOutlet weak var idText: UITextField!
    
    @IBOutlet weak var nameTxt: UITextField!
    
    @IBOutlet weak var authorTxt: UITextField!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    @IBAction func saveBtnPressed(_ sender: Any) {
        
        let id = Int32.random(in: 0...100)
        let isbn = idText.text!
        let name = nameTxt.text!
        let author = authorTxt.text!
        
        if isbn != "" && name != "" && author != "" {
            AlertManager.shared.okayAlert(on: self, title: "Added Successfully", msg: "Book added to CoreData") {
                let book = BookModel(bookid: id, name: name, author: author, ISBN: isbn)
                DispatchQueue.main.async {
                    CDManager().AddToCd(bookToAdd: book)
                    self.navigationController?.popViewController(animated: true)
                }
                
                
                
            }
        }
        
        
    }
    

}


homeVC
//
//  HomeVC.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit
import CoreData

class HomeVC: UIViewController {
    
    @IBOutlet weak var tableSegment: UISegmentedControl!
    
    @IBOutlet weak var bookTable: UITableView!
    
    @IBOutlet weak var cdTable: UITableView!
    
    var selectedBook: BookModel!
    
    var apiBookArr: [BookModel] = [
        BookModel(bookid: 01, name: "To Kill a Mockingbird", author: "Harper Lee", ISBN: "9780446310789"),
        BookModel(bookid: 02, name: "1984", author: "George Orwell", ISBN: "9780451524935"),
        BookModel(bookid: 03, name: "Pride and Prejudice", author: "Jane Austen", ISBN: "9780141439518"),
        BookModel(bookid: 04, name: "The Great Gatsby", author: "F. Scott Fitzgerald", ISBN: "9780743273565"),
        BookModel(bookid: 05, name: "Brave New World", author: "Aldous Huxley", ISBN: "9780060850524"),
        BookModel(bookid: 06, name: "The Catcher in the Rye", author: "J.D. Salinger", ISBN: "9780316769174"),
        BookModel(bookid: 07, name: "Sapiens: A Brief History of Humankind", author: "Yuval Noah Harari", ISBN: "9780062316110"),
        BookModel(bookid: 08, name: "The Hobbit", author: "J.R.R. Tolkien", ISBN: "9780547928227"),
        BookModel(bookid: 09, name: "Dune", author: "Frank Herbert", ISBN: "9780441172719"),
        BookModel(bookid: 10, name: "The Alchemist", author: "Paulo Coelho", ISBN: "9780062315007"),
        BookModel(bookid: 11, name: "Crime and Punishment", author: "Fyodor Dostoevsky", ISBN: "9780141192802"),
        BookModel(bookid: 12, name: "The Name of the Wind", author: "Patrick Rothfuss", ISBN: "9780756404079"),
        BookModel(bookid: 13, name: "Thinking, Fast and Slow", author: "Daniel Kahneman", ISBN: "9780374275631"),
        BookModel(bookid: 14, name: "The Hitchhiker's Guide to the Galaxy", author: "Douglas Adams", ISBN: "9780345391803"),
        BookModel(bookid: 15, name: "Neuromancer", author: "William Gibson", ISBN: "9780441569595"),
        BookModel(bookid: 16, name: "The Road", author: "Cormac McCarthy", ISBN: "9780307387899"),
        BookModel(bookid: 17, name: "Wolf Hall", author: "Hilary Mantel", ISBN: "9780805080681"),
        BookModel(bookid: 18, name: "The Power of Habit", author: "Charles Duhigg", ISBN: "9780812981605"),
        BookModel(bookid: 19, name: "Becoming", author: "Michelle Obama", ISBN: "9781524763138"),
        BookModel(bookid: 20, name: "The Three-Body Problem", author: "Cixin Liu", ISBN: "9780765377067"),
        BookModel(bookid: 21, name: "Atomic Habits", author: "James Clear", ISBN: "9780735211292"),
        BookModel(bookid: 22, name: "The Martian", author: "Andy Weir", ISBN: "9780553418026"),
        BookModel(bookid: 23, name: "Educated", author: "Tara Westover", ISBN: "9780399590504"),
        BookModel(bookid: 24, name: "Snow Crash", author: "Neal Stephenson", ISBN: "9780553380958"),
        BookModel(bookid: 25, name: "A Short History of Nearly Everything", author: "Bill Bryson", ISBN: "9780767915472"),
        BookModel(bookid: 26, name: "The Immortal Life of Henrietta Lacks", author: "Rebecca Skloot", ISBN: "9781400052189"),
        BookModel(bookid: 27, name: "GÃ¶del, Escher, Bach", author: "Douglas Hofstadter", ISBN: "9780465026570")
    ]
    
    var bookArr: [BookModel] = []
    
    
    override func viewWillAppear(_ animated: Bool) {
        super.viewWillAppear(animated)
        self.bookArr = CDManager().readFromCd()
        reloadUI()
    }
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        tableSegment.selectedSegmentIndex = 0
        self.bookArr = CDManager().readFromCd()

        setupTable()
        reloadUI()
    }
    
    
    func setupTable(){
        bookTable.delegate = self
        bookTable.dataSource = self
        
        cdTable.delegate = self
        cdTable.dataSource = self
        
        bookTable.register(UINib(nibName: "BookCell", bundle: nil), forCellReuseIdentifier: "BookCell")
        cdTable.register(UINib(nibName: "BookCell", bundle: nil), forCellReuseIdentifier: "BookCell")
        bookTable.isHidden = false
        cdTable.isHidden = true
    }
    
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if segue.identifier == "GoToUpdate" {
            if let updateVC = segue.destination as? UpdateVC {
                updateVC.bookPassed = selectedBook
            }
        }
    }
    
    
    func reloadUI() {
        DispatchQueue.main.async {
            
            if self.tableSegment.selectedSegmentIndex == 0 {
                self.bookTable.reloadData()
                self.bookTable.isHidden = false
                self.cdTable.isHidden = true

            } else if self.tableSegment.selectedSegmentIndex == 1 {
                self.bookArr = CDManager().readFromCd()
                self.cdTable.reloadData()
                self.cdTable.isHidden = false
                self.bookTable.isHidden = true

            }
        }
    }
    
    
    func deleteFromArr(position: Int) {
        bookArr.remove(at: position)
        DispatchQueue.main.async {
            self.cdTable.reloadData()
        }
    }
    
    
    @IBAction func segmentChanged(_ sender: Any) {
//        print("current selected segment: \(tableSegment.selectedSegmentIndex)")
        reloadUI()
        
    }
    
}



extension HomeVC: UITableViewDelegate, UITableViewDataSource {
    
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        
        return tableSegment.selectedSegmentIndex == 0 ? apiBookArr.count : bookArr.count
    }
    
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {

        guard let cell = tableView.dequeueReusableCell(withIdentifier: "BookCell", for: indexPath) as? BookCell else {
                return UITableViewCell()
        }
            
        let currSeg = tableSegment.selectedSegmentIndex
        
        switch currSeg {
        case 0:
            guard indexPath.row < apiBookArr.count else {
                print("Index out of bounds for apiBookArr")
                return cell
            }
            let book = apiBookArr[indexPath.row]
            configureCell(cell, with: book)
            
        case 1:
            guard indexPath.row < bookArr.count else {
                print("Index out of bounds for bookArr")
                return cell
            }
            let book = bookArr[indexPath.row]
            configureCell(cell, with: book)
            
        default:
            break
        }
        
        return cell
    }
    
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 200
    }
    
    
    private func configureCell(_ cell: BookCell, with book: BookModel) {
        cell.bName.text = book.name
        cell.bAuthor.text = book.author
        cell.bID.text = "\(book.bookid)"
        cell.bISBN.text = book.ISBN
        cell.bUUID.text = "\(book.id)"
    }

    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        
        if tableView == bookTable {
            
            let bookSelected = apiBookArr[indexPath.row]
            CDManager().AddToCd(bookToAdd: bookSelected)
            bookTable.deselectRow(at: indexPath, animated: true)
            AlertManager.shared.okayAlert(on: self, title: "Added Successfully", msg: "Data added to CoreData") {
//                navigationController
            }
        } else if tableView == cdTable {
            cdTable.deselectRow(at: indexPath, animated: true)

        }
    }
    
    func tableView(_ tableView: UITableView, leadingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        if tableView == cdTable {
            
            let updateAction = UIContextualAction(style: .normal, title: "Update") { (action, view, completionHandler) in
            
                self.selectedBook = self.bookArr[indexPath.row]
                self.performSegue(withIdentifier: "GoToUpdate", sender: self)
                
                completionHandler(true)
            }
            updateAction.backgroundColor = .systemOrange
            updateAction.image = UIImage(systemName: "rectangle.and.pencil.and.ellipsis")
            let updateConfig = UISwipeActionsConfiguration(actions: [updateAction])
            
            return updateConfig
        } else {
            let updateConfig = UISwipeActionsConfiguration(actions: [])
            
            return updateConfig
        }
        // Determine which array to use based on segment
    }
    
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        if tableView == cdTable {
            let deleteAction = UIContextualAction(style: .normal, title: "Delete") { [self] action, v, completion in
                //  Alert shown for confirmation
                AlertManager.shared.classicAlert(on: self, title: "Are you sure", msg: "this is an irreversable action", yesBtnAction:  { [self] in
                    
                    //  CoreData's Delete function called
                    let bookToDelete = bookArr[indexPath.row]
                    CDManager().deleteFromCD(book: bookToDelete)
                    deleteFromArr(position: indexPath.row)
                    completion(true)

                }, cancelBtnAction: {
                    completion(true)

                })
            }
            
            deleteAction.backgroundColor = .systemRed
            deleteAction.image = UIImage(systemName: "minus.circle.fill")
            let deleteConfig = UISwipeActionsConfiguration(actions: [deleteAction])
            return deleteConfig
        } else {
            let deleteConfig = UISwipeActionsConfiguration(actions: [])
            
            return deleteConfig
        }
    }
    
    
    
}


UpdateVc
//
//  UpdateVC.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 07/12/24.
//

import UIKit

class UpdateVC: UIViewController {

    @IBOutlet weak var nameTxt: UITextField!
    
    @IBOutlet weak var authorTxt: UITextField!
    
    @IBOutlet weak var isbnTxt: UITextField!
    
    var bookPassed: BookModel!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        showData()
    }
    
    
    func showData() {
        nameTxt.text = bookPassed.name
        authorTxt.text = bookPassed.author
        isbnTxt.text = bookPassed.ISBN
    }
    
    
    @IBAction func UpdatePressed(_ sender: Any) {
        
        let updatedName = nameTxt.text!
        let updatedAuthor = authorTxt.text!
        let updatedISBN = isbnTxt.text!
        
        if updatedName != "" || updatedAuthor != "" || updatedISBN != "" {
            AlertManager.shared.classicAlert(on: self, title: "Are you sure", msg: "this is an irreversable action and cannot undo it", yesBtnAction:  { [self] in
                
                //  CoreData's Update function called
                let updatedBook = BookModel(bookid: bookPassed.bookid, name: updatedName, author: updatedAuthor, ISBN: updatedISBN)
                DispatchQueue.main.async {
                    CDManager().updateInCD(updatedBook: updatedBook)
                    self.navigationController?.popViewController(animated: true)
                }

            }, cancelBtnAction: {

            })
        }
        
        
    }
    

}

bokmodel.swift
//
//  BookModel.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import Foundation


struct BookModel: Codable {
    
    var id = UUID()
    var bookid: Int32
    var name: String
    var author: String
    var ISBN: String
    
}


//different apis for practice:
//https://dummyapi.online/api/movies
//https://www.freetestapi.com/api/v1/movies?limit=5


CDmanager
//
//  CDManager.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit
import CoreData

class CDManager {
    
    func readFromCd() -> [BookModel] {
        
        var bookArr: [BookModel] = []
        
        let delegate = UIApplication.shared.delegate as? AppDelegate

        let managedContext = delegate!.persistentContainer.viewContext
        
        let fetchRes = NSFetchRequest<NSFetchRequestResult>(entityName: "Books")
        
        do {
            let dataArr = try managedContext.fetch(fetchRes)
            
            for d in dataArr as! [NSManagedObject] {
                let UId = d.value(forKey: "id") as! UUID
                let bId = d.value(forKey: "bookid") as! Int32
                let bName = d.value(forKey: "name") as! String
                let bAuthor = d.value(forKey: "author") as! String
                let bIsbn = d.value(forKey: "isbn") as! String
                bookArr.append(BookModel(id: UId, bookid: bId, name: bName, author: bAuthor, ISBN: bIsbn))
//                print("name: \(bName)")
            }
            
        } catch let err as NSError {
            print(err)
        }
        return bookArr
    }
    
    
    func AddToCd(bookToAdd: BookModel) {
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        guard let bookEnt = NSEntityDescription.entity(forEntityName: "Books", in: managedContext) else { return }
        
        let book = NSManagedObject(entity: bookEnt, insertInto: managedContext)
        book.setValue(bookToAdd.id, forKey: "id")
        book.setValue(bookToAdd.bookid, forKey: "bookid")
        book.setValue(bookToAdd.name, forKey: "name")
        book.setValue(bookToAdd.author, forKey: "author")
        book.setValue(bookToAdd.ISBN, forKey: "isbn")
        
        do {
            try managedContext.save()
            print("Book Saved successfully!")
        } catch let err as NSError {
            print(err)
        }
    }
    
    
    //  delete func for CD
    func deleteFromCD(book: BookModel) {
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Books")
        
        fetchRequest.predicate = NSPredicate(format: "bookid = %d", book.bookid)
//        fetchRequest.predicate = NSPredicate(format: "name = %@", book.name)
//        fetchRequest.predicate = NSPredicate(format: "id = %@", "\(book.id)")
        
        do {
            let fetchRes = try managedContext.fetch(fetchRequest)
            let objToDelete = fetchRes[0] as! NSManagedObject
            managedContext.delete(objToDelete)
            
            try managedContext.save()
            print("Book deleted successfully")
            
        } catch let err as NSError {
            print("Somthing went wrong while deleting \(err)")
        }
    }
    
    
    //  update func for CD
    func updateInCD(updatedBook: BookModel) {
        
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Books")
        
        fetchRequest.predicate = NSPredicate(format: "bookid = %d", updatedBook.bookid)
        
        do {
            let rawData = try managedContext.fetch(fetchRequest)
            
            let objUpdata = rawData[0] as! NSManagedObject
            objUpdata.setValue(updatedBook.name, forKey: "name")
            objUpdata.setValue(updatedBook.author, forKey: "author")
            objUpdata.setValue(updatedBook.ISBN, forKey: "isbn")
            
            try managedContext.save()
            print("Data updated successfully")
            
        } catch let err as NSError {
            print("Somthing went wrong while deleting \(err)")
        }
        
        
        
    }
}

alertManager
//
//  AlertManager.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 14/12/24.
//

import UIKit

class AlertManager {
    
    static let shared = AlertManager()
    
    private init() {}
    
    
    func okayAlert(
        on VC: UIViewController,
        title: String,
        msg: String,
        btnTitle: String = "OK",
        btnAction: (() -> Void)? = nil
    ) {
        let alert = UIAlertController(title: title, message: msg, preferredStyle: .alert)
        let action = UIAlertAction(title: btnTitle, style: .default) { _ in
            btnAction?()
        }
        alert.addAction(action)
        VC.present(alert, animated: true)
        
    }

    
    func classicAlert(
        on VC: UIViewController,
        title: String,
        msg: String,
        yesBtnTitle: String = "Yes",
        yesBtnAction: (() -> Void)? = nil,
        cancelTitle: String = "Cancel",
        cancelBtnAction: (() -> Void)? = nil
    ) {
        let alert = UIAlertController(title: title, message: msg, preferredStyle: .alert)
        let cancelAction = UIAlertAction(title: cancelTitle, style: .default) { _ in
            cancelBtnAction?()
        }
        let action = UIAlertAction(title: yesBtnTitle, style: .default) { _ in
            yesBtnAction?()
        }
        alert.addAction(cancelAction)
        alert.addAction(action)

        VC.present(alert, animated: true)
        
    }
    
    
}


appDelegated
//
//  AppDelegate.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "Cd_Segment_GU")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}


SceneDelegate
//
//  SceneDelegate.swift
//  Cd-Segment-GU
//
//  Created by Jaimin Raval on 03/12/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}












CoreDataSession------------
appDelegate.sw
//
//  AppDelegate.swift
//  coreData-session
//
//  Created by mobile1 on 18/11/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack
    func applicationWillTerminate(_ application: UIApplication) {
        self.saveContext()
    }
    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "coreData_session")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}

scenedelegate
//
//  SceneDelegate.swift
//  coreData-session
//
//  Created by mobile1 on 18/11/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}
jokemodel
//
//  JokeModel.swift
//  coreData-session
//
//  Created by mobile1 on 19/11/24.
//

import Foundation

struct JokeModel:Codable{
    let id:Int
    let type:String
    let setup:String
    let punchline:String


viewcontroller
//
//  ViewController.swift
//  coreData-session
//
//  Created by mobile1 on 18/11/24.
//

import UIKit
import CoreData

class ViewController: UIViewController {

    override func viewDidLoad() {
        super.viewDidLoad()
//        writeToCD()
        readToCoreData()
        // Do any additional setup after loading the view.
    }

    func addToCoreData(jokeObject:JokeModel){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        guard let jokeEntity = NSEntityDescription.entity(forEntityName: "Jokes", in: managedContext) else { return }
        
        let joke = NSManagedObject(entity: jokeEntity, insertInto: managedContext)
        
        joke.setValue(jokeObject.id, forKey: "id")
        joke.setValue(jokeObject.type, forKey: "type")
        joke.setValue(jokeObject.setup, forKey: "setup")
        joke.setValue(jokeObject.punchline, forKey: "punchline")
        
        do{
            try managedContext.save()
            print("Saved to Core Data")
        }catch let err as NSError{
            print("Failed to add to Core Data-\(err)")
        }	
    }
    
    func writeToCD(){
        let jokes=JokeModel(id: 401, type: "general", setup: "What do elves post on Social Media?", punchline: "Elf-ies")
        addToCoreData(jokeObject: jokes)
    }
    
    func readToCoreData(){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchData = NSFetchRequest<NSFetchRequestResult>(entityName: "Jokes")
        
        do{
            let res = try managedContext.fetch(fetchData)
            print("Fetch Data")
            for data in res as! [NSManagedObject]{
                print("id-",data.value(forKey: "id") as! Int)
                print("type-",data.value(forKey: "type") as! String)
                print("setup-",data.value(forKey: "setup") as! String)
                print("punchline-",data.value(forKey: "punchline") as! String)
            }
        }
        catch let err as NSError{
            print("Failed to Fetch Data \(err)")
        }
    }
    
    func deleteCoreData(){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchData = NSFetchRequest<NSFetchRequestResult>(entityName: "Jokes")
        
        do{
            let res = try managedContext.fetch(fetchData)
            print("Fetch Data")
            for data in res as! [NSManagedObject]{
                managedContext.delete(data)
            }
            try managedContext.save()
        }catch let err as NSError{
            print("Failed to Fetch Data \(err)")
        }
        
    }
}









CDIMAGE----

Appdelegated
//
//  AppDelegate.swift
//  CDImage
//
//  Created by mobile1 on 30/11/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "CDImage")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}


SceneDelegated
//
//  SceneDelegate.swift
//  CDImage
//
//  Created by mobile1 on 30/11/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}
Coredatamanager
//  CoreDataManager.swift
//  CDImage
//
//  Created by mobile1 on 30/11/24.
//

import Foundation
import CoreData
import UIKit
final class CoreDataManager{
    
    func addfromCd(){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        guard let imgEntity = NSEntityDescription.entity(forEntityName: "ImgData", in: managedContext) else { return }
        
        let image = NSManagedObject(entity: imgEntity, insertInto: managedContext)
        
        let img = UIImage(named: "sim")
        let idata : Data? = img?.pngData()
        image.setValue(idata, forKey: "img")
        
        do{
            try managedContext.save()
            print(idata!)
            
        }catch let err as NSError{
            print("\(err)")
        }
    }
    
    func readfromCD()->[ImageModel]{
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return [] }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let img:[ImageModel]=[]
        
        let fetchData = NSFetchRequest<NSFetchRequestResult>(entityName: "ImgData")
        
        do{
            let result = try managedContext.fetch(fetchData)
            for data in result as! [NSManagedObject]{
                print("\(data.value(forKey: "img")!)")
            }
        }catch let err as NSError{
            print("Failed to Fetch Data \(err)")
        }
        
        return img
    }
}

imagecell
//
//  ImageCell.swift
//  CDImage
//
//  Created by mobile1 on 30/11/24.
//

import UIKit

class ImageCell: UITableViewCell {

    @IBOutlet weak var imgView: UIImageView!
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)

        // Configure the view for the selected state
    }
    
}
ViewController
//
//  ViewController.swift
//  CDImage
//
//  Created by mobile1 on 30/11/24.
//

import UIKit
class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    private var imgArr:[ImageModel]=[]
    @IBOutlet weak var tableVC: UITableView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
//        CoreDataManager().addfromCd()
        imgArr=CoreDataManager().readfromCD()
    }
    
    func setupTable()  {
        tableVC.register(UINib(nibName: "ImageCell", bundle: nil), forCellReuseIdentifier: "imgCell")
        tableVC.delegate=self
        tableVC.dataSource=self
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        imgArr.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "imgCell", for: indexPath) as! ImageCell
        
        return cell
    }
}










CDSession---

//
//  AppDelegate.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "CDSession")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}

//
//  SceneDelegate.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}
//
//  JokeModel.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import Foundation

struct JokeModel:Codable{
    let id:Int
    let type:String
    let setup:String
    let punchline:String
    
}
//
//  ApiManager.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import Foundation
import Alamofire

class ApiManager{
    let urlStr="https://official-joke-api.appspot.com/jokes/random/25"
    
    func fetchAF(completionHandler:@escaping(Result<[JokeModel],Error>)->Void){
        AF.request(urlStr).responseDecodable(of:[JokeModel].self){ response in
            switch response.result{
                case.success(let data):
                    completionHandler(.success(data))
                case .failure(let error):
                    completionHandler(.failure(error))
            }
        }
    }
}
//
//  AddCD.swift
//  CDSession
//
//  Created by mobile1 on 29/11/24.
//

import UIKit
import CoreData
class AddCD: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    var arrjoke:[JokeModel]=[]
    
    @IBOutlet weak var tableVC: UITableView!
    override func viewWillAppear(_ animated: Bool) {
        setupTable()
        
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        readCD()
//        deleteCD()
        // Do any additional setup after loading the view.
    }
    
    func setupTable(){
        tableVC.register(UINib(nibName: "JokeCell", bundle: nil), forCellReuseIdentifier: "JokeCell")
        tableVC.delegate=self
        tableVC.dataSource=self
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        performSegue(withIdentifier: "NavigateCD", sender: arrjoke[indexPath.row].id)
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        arrjoke.count
    }
    func reloadTable(){
            DispatchQueue.main.async{
                self.tableVC.reloadData()
            }
        }
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "JokeCell", for: indexPath) as! JokeCell
        cell.id.text="\(arrjoke[indexPath.row].id)"
        cell.type.text=arrjoke[indexPath.row].type
        cell.setup.text=arrjoke[indexPath.row].setup
        cell.punchline.text=arrjoke[indexPath.row].punchline
        return cell
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        200
    }
    
    func readCD(){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchData = NSFetchRequest<NSFetchRequestResult>(entityName: "JokeEntity")
        do{
            let result = try managedContext.fetch(fetchData)
            for data in result as! [NSManagedObject]{
                let vid=data.value(forKey: "id") as! Int
                let vtype=data.value(forKey: "type") as! String
                let vsetup=data.value(forKey: "setup") as! String
                let vpunch=data.value(forKey: "punchline") as! String
                
                arrjoke.append(JokeModel(id: vid, type: vtype, setup: vsetup, punchline: vpunch))
            }
            tableVC.reloadData()
        }catch let err as NSError{
            print("Failed to Fetch Data \(err)")
        }
    }
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
            let deleteAction = UIContextualAction(style: .destructive, title: "Delete") { action, sourceView, completionHandler in
                self.deleteCD(jokes: self.arrjoke[indexPath.row])
                self.arrjoke.remove(at: indexPath.row)
                self.reloadTable()
            }
            
            let swipeConfig = UISwipeActionsConfiguration(actions: [deleteAction])
            swipeConfig.performsFirstActionWithFullSwipe = false
            return swipeConfig
        }
        
    func deleteCD(jokes:JokeModel){
            guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
            
            let managedContext = delegate.persistentContainer.viewContext
            
            // Create a fetch request to retrieve the joke by id
        
        let a = NSFetchRequest<NSFetchRequestResult>(entityName: "JokeEntity")
        
        print(jokes)
        
        a.predicate = NSPredicate(format: "id == %d", jokes.id)
            
            do {
                let results = try managedContext.fetch(a)
                guard let fetchedJoke = results.first else {
                    print("Joke Not Found")
                    return  }
//                for data in results as [NSManagedObject]{
//                    managedContext.delete(data)
//                }
                managedContext.delete(fetchedJoke as! NSManagedObject)
                try managedContext.save()
            } catch let error as NSError {
                print("Failed to delete joke: \(error)")
            }
        }
}
//
//  DataFetched.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import UIKit
import CoreData
class DataFetched: UIViewController {

    @IBOutlet weak var id: UILabel!
    
    
    @IBOutlet weak var type: UILabel!
    
    
    @IBOutlet weak var setup: UILabel!
    
    
    @IBOutlet weak var punchline: UILabel!
    
    var jokeId: Int?
    
    override func viewDidLoad() {
        super.viewDidLoad()
        if let id = jokeId {
            fetchJokeById(id: id)
        }
    }
    
    func fetchJokeById(id: Int){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        let fetchData = NSFetchRequest<NSFetchRequestResult>(entityName: "JokeEntity")
        fetchData.predicate = NSPredicate(format: "id == %d", id)
        
        do{
            let res = try managedContext.fetch(fetchData)
            print("Fetch Data")
            for data in res.first as! [NSManagedObject]{
                let vid=data.value(forKey: "id") as! Int
                let vtype=data.value(forKey: "type") as! String
                let vsetup=data.value(forKey: "setup") as! String
                let vpunch=data.value(forKey: "punchline") as! String
                
                self.id.text="\(vid)"
                self.type.text=vtype
                self.setup.text=vsetup
                self.punchline.text=vpunch
            }
        }
        catch let err as NSError{
            print("Failed to Fetch Data \(err)")
        }
    }

}
//
//  JokeCell.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import UIKit

class JokeCell: UITableViewCell {
    
    @IBOutlet weak var id: UILabel!
    
    @IBOutlet weak var type: UILabel!
    
    @IBOutlet weak var setup: UILabel!
    
    @IBOutlet weak var punchline: UILabel!
    
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    
}
//
//  ViewController.swift
//  CDSession
//
//  Created by mobile1 on 27/11/24.
//

import UIKit
import CoreData

class ViewController: UIViewController, UITableViewDataSource, UITableViewDelegate {
    
   
    @IBOutlet weak var btnNavigate: UIButton!
    @IBOutlet weak var tableVC: UITableView!
    private var jokeArr:[JokeModel]=[]
    
    override func viewWillAppear(_ animated: Bool) {
        loadApi()
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTable()
//        deleteCD()
        // Do any additional setup after loading the view.
    }
    
    func reloadTable(){
            DispatchQueue.main.async{
                self.tableVC.reloadData()
            }
        }
    
    func setupTable(){
        tableVC.register(UINib(nibName: "JokeCell", bundle: nil), forCellReuseIdentifier: "JokeCell")
        tableVC.delegate=self
        tableVC.dataSource=self
    }
    
    @IBAction func btnRedirect(_ sender: Any) {
        print("------------")
        performSegue(withIdentifier: "NavigateToCD", sender: nil)
    }
    
    func loadApi(){
        ApiManager().fetchAF (completionHandler: { result in
            switch result{
            case .success(let data):
                self.jokeArr.append(contentsOf: data)
                self.tableVC.reloadData()
            
            case .failure(let error):
                print("\(error)")
            }
        })
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 200
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return  }
        
        let managedContext = delegate.persistentContainer.viewContext
        
        guard let jokeEntity = NSEntityDescription.entity(forEntityName: "JokeEntity", in: managedContext) else { return }
        
        let joke = NSManagedObject(entity: jokeEntity, insertInto: managedContext)
        
        joke.setValue(jokeArr[indexPath.row].id, forKey: "id")
        joke.setValue(jokeArr[indexPath.row].type, forKey: "type")
        joke.setValue(jokeArr[indexPath.row].setup, forKey: "setup")
        joke.setValue(jokeArr[indexPath.row].punchline, forKey: "punchline")
        
        do{
            try managedContext.save()
            
            print("Saved to Core Data")
        }catch let err as NSError{
            print("Failed to add to Core Data-\(err)")
        }
        }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return jokeArr.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "JokeCell", for: indexPath) as! JokeCell
        cell.id.text="\(jokeArr[indexPath.row].id)"
        cell.type.text=jokeArr[indexPath.row].type
        cell.setup.text=jokeArr[indexPath.row].setup
        cell.punchline.text=jokeArr[indexPath.row].punchline
        return cell
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
            if segue.identifier == "NavigateCD" {
                if let destinationVC = segue.destination as? DataFetched {
                    if let jokeId = sender as? Int {
                        destinationVC.jokeId=jokeId
                    }
                }
            }
        }
}
contents
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<model type="com.apple.IDECoreDataModeler.DataModel" documentVersion="1.0" lastSavedToolsVersion="23231" systemVersion="23G93" minimumToolsVersion="Automatic" sourceLanguage="Swift" usedWithSwiftData="YES" userDefinedModelVersionIdentifier="">
    <entity name="JokeEntity" representedClassName="JokeEntity" syncable="YES" codeGenerationType="class">
        <attribute name="id" optional="YES" attributeType="Integer 32" defaultValueString="0" usesScalarValueType="YES"/>
        <attribute name="punchline" optional="YES" attributeType="String"/>
        <attribute name="setup" optional="YES" attributeType="String"/>
        <attribute name="type" optional="YES" attributeType="String"/>
    </entity>
</model>











UIkitOddesy

//
//  AppDelegate.swift
//  UIKit-Odyssey
//
//  Created by Jaimin Raval on 05/08/24.
//

import UIKit

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }


}
//
//  SceneDelegate.swift
//  UIKit-Odyssey
//
//  Created by Jaimin Raval on 05/08/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }


}
//
//  JokeCell.swift
//  UIKit-Odyssey
//
//  Created by Jaimin Raval on 26/08/24.
//

import UIKit

class JokeCell: UITableViewCell {
    @IBOutlet weak var jokeLabel: UILabel!
    
    @IBOutlet weak var punchLine: UILabel!
    
    @IBOutlet weak var jokeSetup: UILabel!
    
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }

    override func setSelected(_ selected: Bool, animated: Bool) {
        super.setSelected(selected, animated: animated)

        // Configure the view for the selected state
    }
    
}
//
//  ApiManager.swift
//  UIKit-Odyssey
//
//  Created by mobile1 on 17/09/24.
//

import Foundation
import Alamofire
class ApiManager {
     let urlStr = "https://official-joke-api.appspot.com/jokes/random/5"
    
     func fetchJokeAF(completionHandler:@escaping(Result<[JokeModel], Error>)->Void) {
        AF.request(urlStr).responseDecodable(of:[JokeModel].self){ response in
            switch response.result{
            case.success(let data):
                completionHandler(.success(data))
            case .failure(let error):
                completionHandler(.failure(error))
            }
        }
    }
    
    
    func fetchAF(category:String,completionHandler:@escaping(Result<[JokeModel], Error>)->Void) {
             let urlStr2 = "https://official-joke-api.appspot.com/jokes/\(category)/ten"
             AF.request(urlStr2).responseDecodable(of:[JokeModel].self){ response in
                 switch response.result{
                 case.success(let data):
                     completionHandler(.success(data))
                 case .failure(let error):
                     print("---------------")
                     completionHandler(.failure(error))
                 }
             }
         }
}
//
//  ViewController.swift
//  UIKit-Odyssey
//
//  Created by mobile1 on 04/09/24.
//

import UIKit

class DataFetched: UIViewController {
        var jokeID: Int?
        var jokeType: String?
        var jokeSetup: String?
        var jokePunchline: String?


    @IBOutlet weak var id: UILabel!
    
    @IBOutlet weak var type: UILabel!
    
    @IBOutlet weak var Steup: UILabel!
    
    @IBOutlet weak var PunchLine: UILabel!
    @IBOutlet weak var valueId: UILabel!
    
    @IBOutlet weak var valueType: UILabel!
  
    @IBOutlet weak var valueSetup: UITextView!
    
    @IBOutlet weak var valuePunchLine: UITextView!
    override func viewDidLoad() {
        super.viewDidLoad()
        Steup.lineBreakMode = NSLineBreakMode.byWordWrapping
        Steup.numberOfLines = 0
        PunchLine.lineBreakMode = NSLineBreakMode.byWordWrapping
        PunchLine.numberOfLines = 0
        id.text="id"
        type.text="type"
        Steup.text="Setup"
        PunchLine.text="PunchLine"
        
        valueId.text="\(jokeID!)"
        valueType.text=jokeType
        valueSetup.text=jokeSetup
        valuePunchLine.text=jokePunchline
        // Do any additional setup after loading the view.
    }
    


}
//
//  JokeModel.swift
//  UIKit-Odyssey
//
//  Created by mobile1 on 30/08/24.
//

import Foundation

struct JokeModel:Codable{
    let id:Int
    let type:String
    let setup:String
    let punchline:String
}
//
//  ViewController.swift
//  UIKit-Odyssey
//
//  Created by Jaimin Raval on 05/08/24.
//

import UIKit


class JokesTableVC: UIViewController {

    @IBOutlet weak var jokeTable: UITableView!
    
    @IBOutlet weak var segmentedControl: UISegmentedControl!
    
    private var jokeArr: [JokeModel] = []
    
//    @IBOutlet weak var loadingIndicator: UIActivityIndicatorView!
    
    private var activityIndicator: UIActivityIndicatorView!
    
    override func viewWillAppear(_ animated: Bool) {
//        jokeApi()
        if(jokeArr.isEmpty){
            loadApi(for:segmentedControl.selectedSegmentIndex)
            saveToUsrDefault(usrName: "Jinay")
            printUsrDefault()
        }
//        self.reloadTable()
        
    }
    
    func saveToUsrDefault(usrName:String){
        
        UserDefaults.standard.set(usrName, forKey: "Usr")
    }
    
    func printUsrDefault(){
        let data = UserDefaults.standard.value(forKey: "Usr")
        print("\(data!)")
    }
    @IBAction func handleSegment(_ sender: Any) {
        
        loadApi(for:segmentedControl.selectedSegmentIndex)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTable()
//        loadApi()
    }
    
    func loadApi(for segmentIndex:Int){
        
        activityIndicator.startAnimating()
        self.jokeArr.removeAll()
        let category = segmentedControl.selectedSegmentIndex == 0 ? "general" : "programming"
        ApiManager().fetchAF(category: category, completionHandler: { result in
            
            switch result{
            case.success(let data):
                sleep(3)
                
                self.jokeArr = data
//                self.jokeArr.append(contentsOf: data)
                self.jokeTable.reloadData()

//                self.stopLoadingIndicator()
                self.activityIndicator.stopAnimating()
                
//                self.jokeTable.isHidden=true
            case .failure(let error):
                print("\(error)")
            }
        })
    }
//    func startLoadingIndicator(){
//        DispatchQueue.main.async {
//            self.loadingIndicator.isHidden=false
//            self.loadingIndicator.startAnimating()
//        }
//    }
//    
//    func stopLoadingIndicator(){
//        DispatchQueue.main.async {
//            self.loadingIndicator.isHidden=true
//            self.loadingIndicator.stopAnimating()
//        }
//    }
    
    func reloadTable(){
        DispatchQueue.main.async{
            self.jokeTable.reloadData()
        }
    }
    func setupTable(){
        activityIndicator = UIActivityIndicatorView(style: .large)
        activityIndicator.center = view.center
        view.addSubview(activityIndicator)
        jokeTable.register(UINib(nibName: "JokeCell", bundle: nil), forCellReuseIdentifier: "JokeCell")
        jokeTable.dataSource = self
        jokeTable.delegate = self
    }

}

//  MARK: - tableview methods
extension JokesTableVC: UITableViewDataSource, UITableViewDelegate {
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        //
        return jokeArr.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "JokeCell", for: indexPath) as! JokeCell
        cell.jokeLabel.text=jokeArr[indexPath.row].type
        cell.jokeSetup.text=jokeArr[indexPath.row].setup
        cell.punchLine.text=jokeArr[indexPath.row].punchline
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        self.performSegue(withIdentifier: "NavigateToDetail", sender: jokeArr[indexPath.row])
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 100
    }
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        let deleteAction = UIContextualAction(style: .destructive, title: "Delete") { action, sourceView, completionHandler in
            self.jokeArr.remove(at: indexPath.row)
            self.reloadTable()
            
        }
        let swipeConfig = UISwipeActionsConfiguration(actions: [deleteAction])
        swipeConfig.performsFirstActionWithFullSwipe = false
        return swipeConfig;
    }
    
    
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        if let details = segue.destination as? DataFetched, let joke = sender as? JokeModel {
                details.jokeID = joke.id
                details.jokeType = joke.type
                details.jokeSetup = joke.setup
                details.jokePunchline = joke.punchline
        }
    }
    
    
}






CDINPUTS
//
//  AppDelegate.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "CDInput")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}
//
//  SceneDelegate.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}
//
//  CoreDataManager.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import Foundation
import CoreData
import UIKit

final class CoreDataManager{
    
    func addToCoreData(userObject:UserModel){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext=delegate.persistentContainer.viewContext
        
        guard let Userentity = NSEntityDescription.entity(forEntityName: "Userentity", in: managedContext) else { return }
        
        let user = NSManagedObject(entity: Userentity, insertInto: managedContext)
        
        user.setValue(userObject.id, forKey: "id")
                user.setValue(userObject.username, forKey: "username")
                user.setValue(userObject.password, forKey: "password")
                
                do {
                    try managedContext.save()
                    debugPrint("Saved to CD Successfully")
                    
                } catch let err as NSError {
                    debugPrint("could not save to CoreData. Error: \(err)")
                }
        
    }
    
    
    func readfromCD() -> [UserModel] {
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return [] }
        
        let managedContext=delegate.persistentContainer.viewContext
        
        let fetchRequest = NSFetchRequest<NSFetchRequestResult>(entityName: "Userentity")
        var usr:[UserModel]=[]
        do{
            
            let res = try managedContext.fetch(fetchRequest)
            for data in res as! [NSManagedObject]{
                let id = data.value(forKey: "id") as! Int32
                let username = data.value(forKey: "username") as! String
                let pwd = data.value(forKey: "password") as! String
                
                let usrMod = UserModel(id: id , username: username , password: pwd)
                
                usr.append(usrMod)
                
            }
            print("Fetched Data")
            
        }catch let err as NSError{
            print("\(err)")
        }
        
        return usr
    }
    
    
    func deletefromCD(usr:UserModel){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext=delegate.persistentContainer.viewContext
        
        let usrFetch = NSFetchRequest<NSFetchRequestResult>(entityName: "Userentity")
        print(usr)
        usrFetch.predicate = NSPredicate(format: "id == %d", usr.id)
        
        do{
            let result = try managedContext.fetch(usrFetch)
            guard let fetchedUsr = result.first else {
                print("User Not Found")
                      return  }
            managedContext.delete(fetchedUsr as! NSManagedObject)
            try managedContext.save()
        }catch let err as NSError {
            print("Failed To Delete User:\(err)")
            }
    }
    
    
    func updatefromCD(usr:UserModel){
        guard let delegate = UIApplication.shared.delegate as? AppDelegate else { return }
        
        let managedContext=delegate.persistentContainer.viewContext
        
        let usrFetch = NSFetchRequest<NSFetchRequestResult>(entityName: "Userentity")
        
        usrFetch.predicate = NSPredicate(format: "id == %d", usr.id)
        
        do{
            let rawData = try managedContext.fetch(usrFetch)
            
            let objUpdate = rawData.first as! NSManagedObject
            objUpdate.setValue(usr.username, forKey: "username")
            objUpdate.setValue(usr.password, forKey: "password")
            
            print("obj=\(objUpdate)")
            try managedContext.save()
        }catch let error as NSError{
            print("\(error)")
        }
    }
}
//
//  UserModel.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import Foundation

struct UserModel:Codable{
    let id:Int32
    let username:String
    let password:String
}
//
//  Table Data Added.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import UIKit

class Table_Data_Added: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    private var userArr:[UserModel]=[]
    
    @IBOutlet weak var tableVC: UITableView!
    override func viewWillAppear(_ animated: Bool) {
        self.tableVC.reloadData()
        userArr = CoreDataManager().readfromCD()
    }
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTable()
        
        
        // Do any additional setup after loading the view.
    }
    
    func setupTable(){
        tableVC.register(UINib(nibName: "UserDetail", bundle: nil), forCellReuseIdentifier: "UserDetails")
        tableVC.delegate=self
        tableVC.dataSource=self
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        70
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        userArr.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "UserDetails", for: indexPath) as! UserDetail
        cell.username.text = userArr[indexPath.row].username
        return cell
    }
    
    func tableView(_ tableView: UITableView, trailingSwipeActionsConfigurationForRowAt indexPath: IndexPath) -> UISwipeActionsConfiguration? {
        let deleteAction = UIContextualAction(style: .destructive, title: "Delete") { action, sourceView, completionHandler in
            CoreDataManager().deletefromCD(usr: self.userArr[indexPath.row])
            self.userArr.remove(at: indexPath.row)
            self.tableVC.reloadData()
        }
        
        
        let editAction = UIContextualAction(style: .normal, title: "Edit") {
                    (action, sourceView, completionHandler) in
            self.performSegue(withIdentifier: "NavigateToUpdate", sender: self.userArr[indexPath.row])
                }

        
        let swipeConfig = UISwipeActionsConfiguration(actions: [deleteAction,editAction])
        swipeConfig.performsFirstActionWithFullSwipe = true
        return swipeConfig
    }
    
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
            if let details = segue.destination as? UpdateVC, let joke = sender as? UserModel {
                details.userToUpdate=joke
            }
        }
}
//
//  UpdateVC.swift
//  CDInput
//
//  Created by Admin2 on 07/12/24.
//

import UIKit
import CoreData
class UpdateVC: UIViewController {

    @IBOutlet weak var tid: UITextField!
    
    
    @IBOutlet weak var tusername: UITextField!
    
    
    @IBOutlet weak var tpassword: UITextField!
    
    var userToUpdate: UserModel?
    override func viewDidLoad() {
        super.viewDidLoad()
        
        if let user = userToUpdate{
            tid.text = "\(user.id)"
            tusername.text = user.username
            tpassword.text = user.password
        }
       
    }

    @IBAction func updateToCD(_ sender: Any) {
        let gt = UserModel(id: Int32(tid.text!)!, username: tusername.text!, password: tpassword.text!)
        CoreDataManager().updatefromCD(usr: gt)
        navigationController?.popViewController(animated: true)
    }
    
}
//
//  UserDetail.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import UIKit

class UserDetail: UITableViewCell {

    @IBOutlet weak var username: UILabel!
    override func awakeFromNib() {
        super.awakeFromNib()
        
    }
    
}
//
//  ViewController.swift
//  CDInput
//
//  Created by Admin on 28/11/24.
//

import UIKit
import CoreData

class ViewController: UIViewController {

    @IBOutlet weak var idTF: UITextField!
    
    
    @IBOutlet weak var pTF: UITextField!
    
    
    @IBOutlet weak var uTF: UITextField!
    
    
    @IBOutlet weak var btnSave: UIButton!
    
    
    @IBOutlet weak var btnData: UIButton!
    
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
    }
    
    
    @IBAction func btnSend(_ sender: Any) {
        performSegue(withIdentifier: "NavigateToDetials", sender: nil)
    }
    
    
    @IBAction func SaveToCD(_ sender: Any) {
        let vPTF:String = pTF.text!
        let vUTF:String = uTF.text!
        let vidTF:Int32 = Int32("\(idTF.text!)")!
        let user = UserModel(id: vidTF, username: vUTF, password: vPTF)
        CoreDataManager().addToCoreData(userObject:user)
            }
    
   
}




imageRendering---

//
//  AppDelegate.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import UIKit
import CoreData

@main
class AppDelegate: UIResponder, UIApplicationDelegate {



    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

    // MARK: - Core Data stack

    lazy var persistentContainer: NSPersistentContainer = {
        /*
         The persistent container for the application. This implementation
         creates and returns a container, having loaded the store for the
         application to it. This property is optional since there are legitimate
         error conditions that could cause the creation of the store to fail.
        */
        let container = NSPersistentContainer(name: "ImageRendering")
        container.loadPersistentStores(completionHandler: { (storeDescription, error) in
            if let error = error as NSError? {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                 
                /*
                 Typical reasons for an error here include:
                 * The parent directory does not exist, cannot be created, or disallows writing.
                 * The persistent store is not accessible, due to permissions or data protection when the device is locked.
                 * The device is out of space.
                 * The store could not be migrated to the current model version.
                 Check the error message to determine what the actual problem was.
                 */
                fatalError("Unresolved error \(error), \(error.userInfo)")
            }
        })
        return container
    }()

    // MARK: - Core Data Saving support

    func saveContext () {
        let context = persistentContainer.viewContext
        if context.hasChanges {
            do {
                try context.save()
            } catch {
                // Replace this implementation with code to handle the error appropriately.
                // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
                let nserror = error as NSError
                fatalError("Unresolved error \(nserror), \(nserror.userInfo)")
            }
        }
    }

}

//
//  SceneDelegate.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?


    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not necessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.

        // Save changes in the application's managed object context when the application transitions to the background.
        (UIApplication.shared.delegate as? AppDelegate)?.saveContext()
    }


}
//
//  CatModel.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import Foundation

struct CatModel:Codable{
    let id:String
    let url:String
    let width:Int
    let height:Int
}
//
//  ApiManager.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import Foundation
import Alamofire

class ApiManager{
    let urlStr="https://api.thecatapi.com/v1/images/search?limit=10"
    
    func fetchAF(completionHandler:@escaping(Result<[CatModel],Error>)->Void){
        AF.request(urlStr).responseDecodable(of:[CatModel].self) { response in
            switch response.result{
            case .success(let data):
                completionHandler(.success(data))
            case .failure(let err):
                completionHandler(.failure(err))
            }
        }
        
    }
}
//
//  ViewController.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import UIKit

import Alamofire

class ViewController: UIViewController, UITableViewDelegate, UITableViewDataSource {
    
    @IBOutlet weak var tableVC: UITableView!
    // NSCache to store images in memory for quick access and reduce network calls
    var imageCache = NSCache<NSString, UIImage>()
    var catArr:[CatModel] = []
    override func viewDidLoad() {
        super.viewDidLoad()
        setupTable()
        loadApi()
    }
    
    func setupTable(){
        tableVC.delegate=self
        tableVC.dataSource=self
        
        tableVC.register(UINib(nibName: "CatCell", bundle: nil), forCellReuseIdentifier: "CatCell")
    }
    
    func loadApi(){
        ApiManager().fetchAF (completionHandler: { res in
            switch res{
            case .success(let data):
                self.catArr=data
                DispatchQueue.main.async{
                    self.tableVC.reloadData()
                }
            case .failure(let err):
                print("Error Fetching:-",err)
            }
        })
    }
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        150
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return catArr.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "CatCell", for: indexPath) as! CatCell
        let caturl = catArr[indexPath.row].url
        
        // Check if the image is already cached
        if let cachedImage = imageCache.object(forKey: caturl as NSString) {
            // If the image is cached, set it directly to the image view
            cell.imageView?.image = cachedImage
        } else {
            // If the image is not cached, download it from the URL
            AF.download(caturl).responseData { response in
                switch response.result {
                    case .success(let data):
                    // If image data is successfully downloaded
                        if let image = UIImage(data: data) {
                            // Set the downloaded image to the cell's image view
                            cell.imageView?.image = image
                            // Cache the image for future use
                            self.imageCache.setObject(image, forKey: caturl as NSString)
                        }
                     case .failure(let error):
                         print("Image not Rendering: \(error)")
                }
            }
        }
        return cell
    }
}
//
//  CatCell.swift
//  ImageRendering
//
//  Created by mobile1 on 10/12/24.
//

import UIKit

class CatCell: UITableViewCell {

    @IBOutlet weak var catImage: UIImageView!
    override func awakeFromNib() {
        super.awakeFromNib()
        // Initialization code
    }
    
}


